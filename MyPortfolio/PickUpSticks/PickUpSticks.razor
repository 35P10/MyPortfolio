@page "/PickUpSticks"
@using MyPortfolio.PickUpSticks.Components;
@inject IJSRuntime JSRuntime;

<div id="pickupcontainer" style="position:relative; background-color:azure; width: 100%; height: 100%;">

	@if (gameStatus == 0)
	{
		<p>juega p.</p>	
		<h3>PickUpSticks</h3>
		@for(int i = 0; i < NumberOfSticks; i++ )
		{
			int index = i;
			<Stick Length=@StickHeight Width=@StickSize StartX=@SticksSize[i].Item1 StartY=@SticksSize[i].Item2 Orientation=SticksOrientation[i] ZIndex=@i @ref="ComponentRef" HandleOverlapping="() => checkOverlapping(index)" />
		}
	} 
	else if (gameStatus == 1)
	{
		<p>nice</p>
	}
	else if (gameStatus == 2)
	{
		<p>gameover</p>
	}


</div>
@code {
	Random random = new Random();

	private int Height = 512;
	private int Width = 512;

	private int StickSize = 100;
	private int StickHeight = 24;
	private List<bool> SticksOrientation = new List<bool>();

	public int NumberOfSticks = 20;
	private int ActiveSticks;
	private int gameStatus = -1;

	List<Stick> ComponentRefs = new List<Stick>();
	Stick ComponentRef
	{
		set {
			value.Color = GetRandomColor();
			ComponentRefs.Add(value); 
		}
	}

	private List<Tuple<int, int>> SticksSize = new List<Tuple<int, int>>();

	protected override void OnInitialized()
	{
		Random random = new Random();
		ActiveSticks = NumberOfSticks;
		@for (int i = 0; i < NumberOfSticks; i++)
		{
			SticksOrientation.Add(GetRandomBool());
		}
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			await ObtenerDimensionesElemento();
			@for (int i = 0; i < NumberOfSticks; i++)
			{
				if (SticksOrientation[i] == true)
				{
					SticksSize.Add(Tuple.Create(@random.Next(0, Width - StickSize), random.Next(0, Height - StickHeight)));
				}
				else
				{
					SticksSize.Add(Tuple.Create(@random.Next(0, Width - StickHeight), random.Next(0, Height - StickSize)));
				}
			}

			gameStatus = 0;
			StateHasChanged();
		}
	}

	private bool GetRandomBool()
	{
		return random.Next(0, 2) == 0;
	}

	private string GetRandomColor()
	{
		return random.Next(1, 7) switch
		{
			1 => "#06FBFD", //cyan
			2 => "#FB0206",	// red
			3 => "#FF01FD", // pink
			4 => "#0400F7", // blue
			5 => "#05FC06", // green
			6 => "#FFFE04", // yellow
			_ => "#FFF"
		};
	}

	public bool checkOverlapping(int one)
	{
		for (int i = ComponentRefs[one].ZIndex + 1; i < NumberOfSticks; i++)
		{
			if (ComponentRefs[i].enable == true && ComponentRefs[one].IsOverlapping(ComponentRefs[i]) == true)
			{
				gameStatus = 2;
				StateHasChanged();
				return true;
			}
		}
		ComponentRefs[one].enable = false;
		if (--ActiveSticks == 0) {
			gameStatus = 1;
			StateHasChanged();
		}
		return false;
	}

	private async Task ObtenerDimensionesElemento()
	{
		var dimensiones = await JSRuntime.InvokeAsync<Dimensiones>("getElementSize", "pickupcontainer");
		Console.WriteLine($"Ancho: {dimensiones.Ancho}, Alto: {dimensiones.Alto}");
		Width = dimensiones.Ancho;
		Height = dimensiones.Alto;
		StickSize = Math.Min(Width, Height) * 3 / 4;
	}

	public class Dimensiones
	{
		public int Ancho { get; set; }
		public int Alto { get; set; }
	}

}
